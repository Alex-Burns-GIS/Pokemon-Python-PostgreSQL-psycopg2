#!/usr/bin/env python3

"""
Written by: <Alexander Burns> <z5118440>
Written on: <18/04/2023>

My Pokemon

Description: This script facilitates the creation of your very own Pokemon. 
Drawing on a range of Pokemon databases, the script randomly selects a 
game and a list of 10 Pokemon from that game. The user is then prompted to 
choose their preferred Pokemon from the list. The script proceeds to identify 
and display the abilities of the chosen Pokemon, and the user can select one of 
the available abilities. Next, the script gathers the moves that the selected 
Pokemon can learn through leveling up in the chosen game. The user is prompted 
to select up to 4 moves (or the total number of moves available if less than 4) 
for their Pokemon.

Once the user completes the selection process, the script presents the final 
Pokemon details, including its name, species, type, Pokedex number, ability, 
and chosen moves.

"""

import sys
import psycopg2
import helpers
import re
from random import Random

### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None

### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret

def main():
    global db, rng

    with db.cursor() as cur:
        # Set seed for random number generation
        cur.execute("SELECT setseed(%s)", (rng.random(),))

        # Select a random game from the database
        cur.execute("SELECT Name FROM games ORDER BY random() LIMIT 10")
        games = [row[0] for row in cur.fetchall()]
        selected_game = games[menu(games)]

        # Select a random Pokémon from the selected game
        # Join 'pokemon' and 'pokedex' tables to retrieve Pokemon names and 
        # their corresponding Pokedex IDs for the selected game.
        cur.execute("""
            SELECT p.Name, p.ID, p_dex.Regional_ID, p_dex.National_ID 
            FROM pokemon p 
            JOIN pokedex p_dex ON p.ID = p_dex.National_ID 
            WHERE p_dex.Game = (SELECT ID FROM Games WHERE Name = %s) 
            ORDER BY random() 
            LIMIT 10
        """, (selected_game,))
        pokemons = [row for row in cur.fetchall()]
        pokemon_names = [pokemon[0] for pokemon in pokemons]
        selected_index = menu(pokemon_names)
        selected_pokemon_name, selected_pokemon_id, regional_id, national_id = pokemons[selected_index]

        # Select a random ability for the selected Pokémon
        # Join 'abilities' and 'knowable_abilities' tables to retrieve the 
        # abilities that the selected Pokemon can have.
        cur.execute("""
            SELECT a.Name, a.ID 
            FROM abilities a
            JOIN knowable_abilities ka ON a.ID = ka.Knows
            WHERE ka.Known_By = %s::pokemon_id
            ORDER BY a.ID
        """, (selected_pokemon_id,))
        abilities = [row for row in cur.fetchall()]
        if not abilities:
            selected_ability_name = "None"
        else:
            selected_ability_name, selected_ability_id = abilities[menu([ability[0] for ability in abilities])]

        # Select 4 random moves for the selected Pokémon
        # Join 'Moves', 'Types', and 'Learnable_Moves' tables to retrieve the 
        # moves the selected Pokemon can learn by leveling up in the selected 
        # game, along with move type information.
        cur.execute("""
        SELECT DISTINCT m.Name, m.ID, m.Of_Type, t.Name AS Type_Name, m.Category, m.POWER, m.Accuracy
        FROM Moves m
        JOIN Types t ON m.Of_Type = t.ID
        JOIN Learnable_Moves lm ON m.ID = lm.Learns
        JOIN Requirements req ON lm.Learnt_When = req.ID
        WHERE lm.Learnt_By = %s::pokemon_id
        AND lm.Learnt_In = (SELECT ID FROM Games WHERE Name = %s)
        AND req.Assertion LIKE 'Level:%%'
        ORDER BY m.ID
        """, (selected_pokemon_id, selected_game))
        moves = [{'name': row[0], 'id': row[1], 'type_id': row[2], 'type_name': row[3], 'category': row[4], 'power': row[5], 'accuracy': row[6]} for row in cur.fetchall()]

        # Use pop() method and menu function to select up to 4 unique moves
        selected_moves = []
        for _ in range(min(4, len(moves))):
            move_selection = menu([m['name'] for m in moves])
            selected_move = moves.pop(move_selection)
            selected_moves.append(selected_move)

        # Get species and types for the selected Pokémon
        # Join 'Pokemon' and 'Types' tables twice (as Pokemon can have up 
        # to two types), and 'Pokedex' table once to retrieve the species and 
        # types for the selected Pokemon.
        cur.execute("""
            SELECT Species, t1.Name AS First_Type, t2.Name AS Second_Type, p_dex.National_ID
            FROM Pokemon p
            JOIN Types t1 ON p.First_Type = t1.ID
            LEFT JOIN Types t2 ON p.Second_Type = t2.ID
            JOIN Pokedex p_dex ON p.ID = p_dex.National_ID
            WHERE p.ID = %s::pokemon_id
        """, (selected_pokemon_id,))
        species, first_type, second_type, national_id = cur.fetchone()

        # Use RegEx to format national_id for Pokedex number
        national_id_formatted = national_id.strip("()")
        national_id_formatted = re.sub(r',\d+', '',  national_id_formatted)

        # Print Pokémon information
        print(f"Here is your new Pokemon (from Pokemon {selected_game}):\n")
        print(f"Name: {selected_pokemon_name}")
        print(f"Species: {species}")
        print(f"Type: {first_type}", end="")
        if second_type:
            print(f" + {second_type}")
        else:
            print()     
        print(f"Pokedex Number: {regional_id} ({national_id_formatted})")
        print()
        print(f"Ability: {selected_ability_name}")
        print("\nMoves:")

        for move in selected_moves:
            move_name = move['name']
            type_name = move['type_name']
            category = move['category']
            power = move['power']
            accuracy = move['accuracy']
            print(f"        {move_name} [{type_name}] (Category: {category}, Power: {power}, Accuracy: {accuracy})")

if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)
